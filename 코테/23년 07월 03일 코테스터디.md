# 07/03 코테 스터디

작성 일시: 2023년 7월 3일 오후 3:13
최종 편집 일시: 2023년 7월 3일 오후 3:20
작성자: myung hun kang
참석자: myung hun kang, 재욱 김
상태: Backlog

## Dynamic Programming (동적 계획법)

```jsx

const arr=[]

function dp (x) {
분할 정복
if(arr[x] !== 0) return arr[x]
재귀
}
```

**1) Bottom-Up (Tabulation 방식) - 반복문 사용**

**2) Top-Down (Memoization 방식) - 재귀 사용**

**① Bottom-Up 방식**

이름에서 보이듯이, **아래에서 부터 계산을 수행 하고 누적시켜서 전체 큰 문제를 해결하는 방식**이다.

메모를 위해서 dp라는 배열을 만들었고 이것이 1차원이라 가정했을 때, dp[0]가 기저 상태이고 dp[n]을 목표 상태라고 하자. Bottom-up은 dp[0]부터 시작하여 반복문을 통해 점화식으로 결과를 내서 dp[n]까지 그 값을 전이시켜 재활용하는 방식이다.

**왜 Tabulation?**

사실 위에서 메모하기 부분에서 Memoization이라고 했는데 Bottom-up일 때는 Tabulation이라고 부른다.

왜냐면 반복을 통해 dp[0]부터 하나 하나씩 채우는 과정을 **"table-filling"** 하며, 이 Table에 저장된 값에 직접 접근하여 재활용하므로 **Tabulation**이라는 명칭이 붙었다고 한다.

사실상 근본적인 개념은 결과값을 기억하고 재활용한다는 측면에서 메모하기(Memoization)와 크게 다르지 않다.

**② Top-Down 방식**

이는 dp[0]의 기저 상태에서 출발하는 대신 dp[n]의 값을 찾기 위해 **위에서 부터 바로 호출을 시작**하여 dp[0]의 상태까지 내려간 다음 해당 **결과 값을 재귀를 통해 전이시켜 재활용하는 방식**이다.

피보나치의 예시처럼, f(n) = f(n-2) + f(n-1)의 과정에서 함수 호출 트리의 과정에서 보이듯, n=5일 때, f(3), f(2)의 동일한 계산이 반복적으로 나오게 된다.

이 때, 이미 이전에 계산을 완료한 경우에는 단순히 메모리에 저장되어 있던 내역을 꺼내서 활용하면 된다. 그래서 가장 최근의 상태 값을 메모해 두었다고 하여 **Memoization** 이라고 부른다.

### 다음시간 금요일까지

목표 : easy 2개 medium 1개