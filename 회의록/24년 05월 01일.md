# 05/01 기술 스터디

작성 일시: 2024년 5월 1일 오후 6:58
최종 편집 일시: 2024년 5월 1일 오후 7:50
작성자: 재욱 김
참석자: 재욱 김, 명훈, 김진영
상태: Backlog

## 이번시간

- **프런트엔드 개발을 위한 보안 입문**
- Chapter 3 : HTTP 까지 읽어보고 오기.

- 진영
    
    ### HTTP의 약점
    
    1. 통신 데이터 도청이 가능한 점
        
        HTTP는 통신 데이터를 **암호화하는 시스템은 없다**. 
        
        사용자가 사이트에 로그인하려고 할 때, 통신 데이터의 **도청이 가능하다면 공격자는 사용자의 로그인 ID와 패스워드의 정보를 알 수 있다**.
        
        ![Untitled](05%2001%20%E1%84%80%E1%85%B5%E1%84%89%E1%85%AE%E1%86%AF%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%20f56c6c8f840f4baf99651f31c7cbd616/Untitled.png)
        
    
    1. 통신 상대의 진위 여부 확인이 어려운 점
        
        HTTP는 통신 대상 서버가 **실제 서버인지 진위 여부를 확인하는 시스템이 없어**서 암호화되지 않은 HTTP 통신 경로는 **공격자가 요청 URL로 서버인 척할 수 있다**. 
        **브라우저는 URL로 통신 상대를 특정하므로** 통신 상대의 진위 여부를 확인할 수 없다.
        
        ![Untitled](05%2001%20%E1%84%80%E1%85%B5%E1%84%89%E1%85%AE%E1%86%AF%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%20f56c6c8f840f4baf99651f31c7cbd616/Untitled%201.png)
        
    2. 통신 과정에서 데이터 수정 여부가 학인이 안 되는 점
        
        통신 경로에서는 통신 내용이 올바른지 검증하는 구조가 없다.
        상대가 전송한 데이터와 전송받은 데이터가 일치하는지 검증할 수 없기 때문에 통신 과정에서 공격자가 **데이터 내용을 수정하더라도 알 수 없다**.
        
        ![Untitled](05%2001%20%E1%84%80%E1%85%B5%E1%84%89%E1%85%AE%E1%86%AF%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%20f56c6c8f840f4baf99651f31c7cbd616/Untitled%202.png)
        
    
    ### HTTP 약점을 해결하는 TLS
    
    HTTP의 세 가지 약점을 해결하려면 HTTPS(http over TLS) 사용해 통신해야 한다. HTTPS는 TLS라고 하는 통신 프로토콜믈 사용해 HTTP 데이터를 암호화해서 통신하는 구조다. 
    HTTP 데이터 통신을 하기 전에 TLS handshake라고 하는 일련의 암호 통신 과정을 진행한다.
    TLS를 사용하는 통신은 ‘통신 데이터 암호화’，‘통신 상대 검증’，‘통신 데이터 변경 체크’를 실행할 수 있다. 
    
    1. 통신데이터 암호화
        
        TLS는 데이터를 암호화하는 기능과 데이터의 변조를 막는 기능을 제공한다.
        평문 데이터를 암호화하여 전송하면 상대는 암호문을 복호화하여 데이터의 내용을 볼 수 있다. 
        암호화와 복호화에 필요한 키는 브라우저와 서버의 통신을 통해 안전하게 공유되며, **키를 가지고 있을 때만 암호문을 복호화**할 수 있다.
        공격자가 HTTPS 통신을 도청하려고 해도 비밀키를 갖고 있지 않으므로 **데이터의 내용을 볼 수없다**. 
        비밀키는 TLS의 통신마다 생성되는 일시적인 것이며, **통신이 종료되면 폐기**되므로 서버가 공격당해도 비밀 키는 유출되지 않는다.
        
        ![Untitled](05%2001%20%E1%84%80%E1%85%B5%E1%84%89%E1%85%AE%E1%86%AF%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%20f56c6c8f840f4baf99651f31c7cbd616/Untitled%203.png)
        
    2. 통신 상대 검증
        
        TLS는 전자 인증서로 통신 상대를 확인하며, 전자 인증서는 신뢰 가능한 기관인 CA(certificate authority)에서 발행한다. 
        서버에서 전송된 인증서는 브라우저가 검증하고 다시 브라우저와 OS에 있는 인증서와 대조한다. 
        CA에서 발행되지 않은 인증서가 사용되면 브라우저는 경고를 표시한다.
        
        ![Untitled](05%2001%20%E1%84%80%E1%85%B5%E1%84%89%E1%85%AE%E1%86%AF%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%20f56c6c8f840f4baf99651f31c7cbd616/Untitled%204.png)
        
    3. 통신 데이터 변경 체크
        
        데이터의 내용을 볼 수 없더라도 공격자는 암호문을 변조할 가능성이 있다. 
        따라서 안전하게 데이터를 주고받으려면 데이터에 변조가 없는 것을 확인해야 한다. 
        이를 위해 TLS는 ‘인증 태그’라는 검증용 데이터를 사용한다. 
        인증 태그는 데이터의 암호화와 동시에 작성되어 상대에게 전송되며, 수신자는 복호화와 동시에 인증 태그를 사용해 암호문의 변조를 체크한다. 
        만약 **변조가 발생한 경우에는 해당 데이터를 사용하지 않고 에러로 통신을 종료**한다. 
        변조의 체크는 HTTP 통신뿐만 아니라 TLS 핸드세이크 중에도 진행된다.
        
    
    ### HTTPS 도입 권장
    
    ‘http://’로 시작하는 웹 애플리케이션에 접속할 때 브라우저의 URL 입력창에 안전하지 않은 통신을 사용 중이라는 경고문을 표시한다.
    
    접속하려는 웹 애플리케이션이 안전하지 않으면 사용자에게 해당 내용을 알려 사용자를 보호한다.
    웹 애플리케이션 개발자는 사용자 데이터의 보안을 유지하기 위해 모든 페이지에 HTTPS를 도입해야 한다.
    
    ### 안전한 콘텍스트만 이용 가능한 AP
    
    웹의 가능성을 넓히고자 브라우저에는 새로운 기능이 계속 추가되고 있다. 
    오프라인에서도 웹 애플리케이션 화면의 표시가 가능한 Service Workers, 웹에서 결제할 수 있는 Payment Request API 등 최근 몇 년 동안 웹을 더 다양하게 만들어 주는 강력한 기능이 브라우저에 추가됐다.
    
    기능이 강력해지면 웹의 가능성을 높이는 동시에 공격자가 악용할 수 있는 여지도 더 많아진다.
    예를 들어 Payment Request API는 신용카드 정보를 입력하지 않아도 브라우저에 결제 정보가 저장되어 있다면 결제할 수 있는 API다. 
    통신 과정에서 웹 페이지가 바뀌어 악의적인 스크립트가 포함되면 브라우저에서 결제 정보가 유출되거나 악용될 가능성이 있다.
    
    이와 같은 공격으로부터 **사용자를 보호하기 위해 앞서 소개한 브라우저의 강력한 기능들은 Secure Context 에서만 이용하도록 제한**한다.
    Secure Context는 인증과 보안의 일정 기준을 만족하는 Window와 Worker 등의 콘텍스트를 가리킨다.
    다음 조건을 만족하면 Secure Context라고 볼 수 있다.
    
    - https:// 또는 wss://의 암호화 통신을 사용
    - http://localhost，http://127.0.0.1, file://의 URL로 시작하는 로컬 호스트 통신
    
    Secure Context의 스펙은 W3C의  'Secure Context’ 에 정의되어 있으며, Secure Context로 볼 수 있는 패턴이 도형으로 정리되어 있다.
    
    Secure Context의  요건인 브라우저의 기능의 자세한 사항은 MDN의  'Features restricted to secure contexts를 확인하면 된다.
    
    ### Mixed Content의 위험성
    
    HTTPS를 사용한 웹 애플리케이션에서 HTTP 통신을 사용하는 리소스가 혼재되어 있는 상태를 Mixed Content라고 한다. 
    웹 애플리케이션이 HTTPS를 도입했다고 하더라도 사용하는 자바스크립트와 이미지 등의 하부 리소스가 HTTP 통신을 사용하면 안전하다고 말할 수 없다.
    
    HTTP로 받은 자바스크립트 파일을 HTTPS의 웹 애플리케이션에서 호출하는 상황을 생각해보자.
    자바스크립트 파일을 가져오는 통신은 암호화되어 있지 않으므로 공격자는 자바스크립트 파일내부를 도청하거나 수정할 수 있게 된다.
    
    ![Untitled](05%2001%20%E1%84%80%E1%85%B5%E1%84%89%E1%85%AE%E1%86%AF%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%20f56c6c8f840f4baf99651f31c7cbd616/Untitled%205.png)
    
    이와 같은 문제를 피하려면 Mixed Content가 없도록 해야 한다. 
    Mixed Content는 Passive mixed content와 Active mixed content의 두 종류의 패턴이 있으며 각각 웹 애플리케이션에 미치는 영향은 다르다.
    
    **Passive mixed content**는 **이미지와 영상, 음성 파일과 같은 리소스가 Mixed Content를 발생**시키는 패턴이다. 
    이와 같은 리소스가 변경되면 잘못된 정보가 표시될 수 있지만 브라우저에서 실행되는 코드는 포함하지 않으므로 **영향이 적다**고 볼 수 있다
    
    ![Untitled](05%2001%20%E1%84%80%E1%85%B5%E1%84%89%E1%85%AE%E1%86%AF%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%20f56c6c8f840f4baf99651f31c7cbd616/Untitled%206.png)
    
    반대로 **Active mixed content**는 **자바스크립트와 CSS 등 브라우저에서 실행되는 코드**에 대한 Mixed Content 패턴이다.
    이 코드가 변경되면 보안 공격과 같은 문제가 발생할 위험이 높아진다.
    
    구글 크름, 파이어폭스, 사파리 등 대부분 브라우저는 다른 사이트에서 전송되는 **Active mixed content의 하부 리소스 접근이 이미 차단**되어 있다. 
    HTTP로 전송되는 자바스크립트와 CSS는 변경되지 않았더라도 차단이 되어 웹 애플리케이션이 제대로 동작하지 않을 때도 있다.
    
    ### HSTS를 사용해 HTTPS 통신 강제하기
    
    HTTPS를 사용하는 웹 애플리케이션이라도 HTTP 접속을 허용할 때가 있다. 
    예전에는 HTTP 통신 밖에 없었으므로 `http://`로 시작하는 URL로 다른 웹 애플리케이션에서 링크를 거는 것과 같은 방식이 많았다. 
    웹 애플리케이션에서 HTTPS를 사용하고 HTTP 통신을 멈추면 `http://`로 시작하는 URL에서의 접속은 불가능해진다. 
    이 문제를 피하기 위해 HTTPS를 사용하는 웹 애플리케이션도 HTTP 전송을 계속 허가하는 경우가 있다.
    
    ![Untitled](05%2001%20%E1%84%80%E1%85%B5%E1%84%89%E1%85%AE%E1%86%AF%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%20f56c6c8f840f4baf99651f31c7cbd616/Untitled%207.png)
    
    이와 같은 애플리케이션이라도 HSTS(HTTP strict transport security) 구조를 적용하면 사용자가 HTTPS통신을 사용하도록 강제할 수 있다. 
    HSTS를 유효화하려면 응답 헤더에 Strict-Transport-Security 헤더를 추가한다. 
    브라우저는 Strict-Transport-Security 헤더를 받으면 이후의 웹 애플리케이션 요청은 HTTPS를 사용한다(그림 3-32).
    
    ![Untitled](05%2001%20%E1%84%80%E1%85%B5%E1%84%89%E1%85%AE%E1%86%AF%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%20f56c6c8f840f4baf99651f31c7cbd616/Untitled%208.png)
    
    HSTS가 사용되는 예로, 깃허브는 HSTS에 대응한다(집필 시점 2022/12). 
    응답 헤더를 살펴보면 다음과 같이 Strict-Transport-Security가 추가된 것을 알 수 있다.
    `strict-transport-security: max-age=31536000;  includeSubdomains;   preload`
    HSTS는 directive라고 하는 설정값에 따라 동작을 바꿀 수 있다. 
    앞의  깃허브에서는 세 가지의 directive가 설정되어 있다.
    
    - `max-age=31536000`
    - `includeSubdomains`
    - `preload`
    
    `max-age`를 지정하면 HSTS를 적용하는 시간을 설정하며, 값은 초 단위로 지정한다. 
    위의 예에서 사용한 31，536,000초는 1년이다. 
    `max-age`는 `Strict-Transport-Security` 헤더에서 필수 항목이다. 
    `includeSubdomains`를 지정하면 웹 애플리케이션의 서브 도메인에도 HSTS를 적용할 수 있다(그림 3-33).
    
    ![Untitled](05%2001%20%E1%84%80%E1%85%B5%E1%84%89%E1%85%AE%E1%86%AF%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%20f56c6c8f840f4baf99651f31c7cbd616/Untitled%209.png)
    
    **HSTS Preload** 구조를 사용하면 **preload**가 추가된다. 
    처음 접속한 시점부터 HTTPS 통신을 사용하기 위한 구조가 HSTS Preload다. 
    HSTS는 응답 헤더를 통해 유효화되므로 한 번이라도 접속하지 않으면 HSTS를 유효화할 수 없고, 그러므로 첫 번째 접속 시에는 HTTPS를 강제할 수 없다.
    
    첫 번째 접속부터 HTTPS 통신을 하기 위해 브라우저는 HSTS Preload 리스트를 조회해야 한다.
    접속하려는 도메인명이 리스트에 있으면 HTTPS로 접속한다(그림 3-34).
    
    ![Untitled](05%2001%20%E1%84%80%E1%85%B5%E1%84%89%E1%85%AE%E1%86%AF%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%20f56c6c8f840f4baf99651f31c7cbd616/Untitled%2010.png)
    
    HSTS Preload 리스트의 도메인을 추가하고 싶믈 때는 HSTS Preload List Submission 의 지침을 참고해 신청해야 한다.
    

- 명훈
    
    # 1장
    
    ## 비기능 요건의 중요성
    
    ### 기능 요건
    
    - 시스템에서 반드시 구현되어야 하는 요건
    - 사용자의 요구를 만족시킴
    - 구체적으로 이미지화하기 쉬움
        
        ex: 티켓 판매 사이트에서 티켓의 종류 선택과 수량 입력 기능
        
    
    ### 비기능 요건
    
    - 시스템 사용의 주목적이 되지 않는 요건
    - 사용자의 요구를 직접적으로 만족시키는 것은 아님
    - 직접적이지 않고 이미지화가 어려움
        
        ex: 위와 같은 예시에서 3초 이내로 서버에서 응답 결과를 반환할 것, 접속자가 증가하더라도 서버가 다운되지 않을 것 
        
    
    > 보안은 비기능 요건 중 하나
    > 
    
    ## 웹 취약성과 동향
    
     
    
    ### 정보처리추진기구(IPA)
    
    - sql 인젝션
    - os 커멘드 인젝션
    - path 파라미터 미체크 / 디렉터리 트래버설
    - 취약한 세션 관리
    - xss
    - csrf
    - http 헤더 인젝션
    - 메일 헤더 인젝션
    - 클릭재킹
    - 버퍼 오버플로
    - 접근 제어 , 권한 제어 누락
    
    ### OWAP Top10
    
    - AO1 : 취약한 접근 통제
    - AO2:  암호화 실패
    - AO3: 인젝션
    - AO4: 안정성이 확인되지 않은 설계
    - AO5: 보안 설정 실수
    - AO6: 취약하고 오래된 컴포넌트
    - AO7: 식별과 인증의 실패
    - AO8: 소프트웨어와 데이터 무결성 문제
    - AO9: 보안 관련 로그와 모니터링 실패
    - AO10: SSRF
    
    <aside>
    💡 - 취약성이란 설계와 코딩 시 유입되는 버그다
    - 비기능 요건은 경영에도 영향을 줄 수 있을 정도로 중요하며 보안 관련 사고가 발생하면 회사에 큰 손실이 발생할 가능성도 있다. 
    - 보안 동향은 시대 배경과 공격 수단의 변화에 따라 해마다 변한다.
    
    </aside>
    
    # 3. HTTP
    
    ## URL
    
    인터넷에서 리소스가 위치하는 장소를 나타내는 문자열
    
    브라우져는 URL을 통해 찾은 서버와 데이터를 통신한다.   
    
    ### DNS
    
    URL을 사용해 서버에 접속하기 위해 필요한 시스템 
    
    ### TCP/IP
    
    컴퓨터에서 통신을 할 때 양쪽 모두 정해진 규약에 따라 데이터를 주고받아야 하는데 이 규약을 통신 프로토콜이라고 함. 
    이 통신 프로토콜 중 하나가 http 이고 통신 사양은 IETF 라는 표준화 기구에서 RFC 문서로 작성해 관리 중 
    
    TCP와 IP 를 포함하는 통신 프로토콜을 총칭해 TCP/IP 라고 하며 4계층으로 구성
    
    ![Untitled](05%2001%20%E1%84%80%E1%85%B5%E1%84%89%E1%85%AE%E1%86%AF%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%20f56c6c8f840f4baf99651f31c7cbd616/Untitled%2011.png)
    
    HTTP/1.1 과 HTTP/2 는 TCP 방식으로 작동하지만 HTTP/3는 UDP로 작동
    
    TCP와 UDP 는 IP를 통해서 작동
    
    ![Untitled](05%2001%20%E1%84%80%E1%85%B5%E1%84%89%E1%85%AE%E1%86%AF%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%84%83%E1%85%B5%20f56c6c8f840f4baf99651f31c7cbd616/Untitled%2012.png)
    
    ### HTTP 메서드
    
    메서드의 보안과 관련된 특징
    
    - GET, HEAD, OPTIONS, TRACE : 서버에서 리소스를 변경하는 부장용이 없으므로 안전한 메서드
    - POST, PUT, DELETE: 부작용의 가능성이 있는 메서드
    - CONNECT :  데이터를 전달하는 터널 같은 역할을 수행, HTTPS 에서는 반드시 필요하지만 수신자를 제한하지 않으면 악용될 수 있다.
    
     
    
    ## HTTPS
    
    ### HTTP의 약점
    
    1. 통신 데이터 도청이 가능
    2. 통신 상대의 진위 여부 확인이 어려움
    3. 통신 과정에서 데이터 수정 여부가 확인이 안된다
    
    ### HTTP 약점을 해결하는 TLS
    
    HTTP 데이터를 암호화해서 통신하는 구조 
    
    TLS 핸드셰이크로 암호 통신과정을 진행
    
    > 통신 데이터 암호화 → 통신 상대 검증 → 통신 데이터 변경 체크
    > 
    
    1. 통신 데이터 암호화 
        
        평문 데이터를 암호화해서 전달 → 상대는 암호문을 복호화해서 데이터 내용을 읽음 
        
        - 암호화와 복호화에 필요한 키는 브라우져와 서버의 통신을 통해 안전하게 공ㅇ유
    
    1. 통신 상대 검증
        
        전자 인증서로 확인할 수 있다. 
        
        인증서는 CA에서 발행한다. 
        
    
     
    
    1. 통신 데이터 변경 체크
        
        TLS는 인증 태그라는 검증용 데이터를 통해 데이터가 이동 중 변조가 없는 것을 확인한다.
        
        - 변조 체크는 HTTP 통신뿐만 아니라 TLS 핸드셰이크 중에도 진행된다.
    
    ### Secure Context
    
    인증과 보안의 일정 기준을 만족하는 window와 worker 등의 콘텍스트
    
    - https:// 또는 wss:// 의 암호화 통신을 사용
    - http://localhost, http://127.0.0,1, file://의 URl 로 시작하는  로컬 호스트 통신
    
    ## Mixed Content 의 위험성
    
    웹 통신을 https로 해도 하위 리소스를 http 로 통신하면 안전하지 않다.
    
    **Passive mixed content** : 이미지와 영상, 음성 과 같은 리소스가 Mixed Content를 발생시키는 패턴 
    
    → 이런 리소스가 변경되면 잘못된 정보가 표시될 수 있지만, 브라우저에서 실행되는 코드는 없으므로 영향이 적다고 볼 수 있다.
    
    **Active mixed content** : js, css 등 브라우져에서 실행되는 코드에 대한 Mixed Content 
    
    → 보안 위험이 높아진다. 
    
    <aside>
    💡 크롬, 파이어폭스,  사파리 등 대부분의 브라우저는 다른 사이트에서 전송되는 Active mixed content의 하부 리소스 접근이 차단되어 있다.
    
    </aside>
    
    ### HSTS를 사용해 HTTPS 통신 강제하기
    
    예전 http를 아직 사용하는 쪽이 많아서 https 를 사용하는 웹 앱도 http 전송을 계속 허가하는 경우가 있다.
    
    이런 앱이라도 HSTS 구조를 적용하면 사용자가 HTTPS 통신을 사용하도록 강제할 수 있다.
    
    → 응답 헤더에 Strict-Transport-Security 헤더를 추가한다.
    
     
    
    HSTS 는 directive라고 하는 설정값에 따라 동작을 바꿀 수 있다. 깃허브에서는 3가지의 설정이 되어있다.
    
    - max-age : hsts 적용시간 초단위
    - includeSubdomains: 웹 앱의 서브 도메인에도 적용할 수 있다.
    - preload : preload가 추가된다.  → 처음 접속부터 https 통신을 사용하기 위한 구조
        
        hsts preload 리스트를 조회해 접속하려는 도메인 명이 있으면 https로 접속한다.
        
        → hsts preload 를 추가하고 싶으면 HSTS Preload List Submission 지침을 참고해 신청해야 한다. 
        
    
    ## 마무리
    
    - 웹은 HTTP를 사용해 통신한다.
    - HTTP는 TCP/IP 프로토콜의 하나다.
    - HTTPS 는 통신을 암호화하고 상대를 증명해 HTTP 약점을 보완한다.
    - 웹 앱의 모든 통신에 HTTPS 도입을 추진 중이다.

- 재욱
    
    # Chapter 3. HTTP
    
    - HTTP. 통신 프로토콜 규약.
    
    ## 3.1 HTTP 기초
    
    - 브라우저는 서버를 특정하기 위해 URL과 DNS 방식을 사용.
    - DNS와 HTTP는 TCP/IP 방식 사용.
    
    ### 3.1.1 URL
    
    - 리소스가 위치하는 장소를 나타내는 문자열. (uniform resource locator)
    - 스키마명(프로토콜) 호스트명 포트번호 경로명
    - 으로 구성.
    
    ### 3.1.2 DNS (domain name system)
    
    - FQDN (fully qualified domain name) = 호스트 + 도메인
    - 호스트명으로 DNS 서버에서 URL 서버의 IP 주소 확인하여 접속.
    
    ### 3.1.3 TCP/IP
    
    - TCP/IP 는 4계층으로 구성.
    
    ### 3.1.4 HTTP 메시지
    
    ### 3.1.5 HTTP 메서드
    
    - GET, HEAD, OPTIONS, TRACE 메서드는 데이터의 생성, 업데이트, 삭제 등 서버에서 리소스를 변경하는 부작용이 없으므로 RFC 7231 스펙에서는 안전한 메서드로 간주.
    - POST, PUT, DELETE는 부작용의 가능성이 있는 메서드.
    - CONNECT는 통신을 중계하는 프록시 서버가 통신 데이터를 볼 수 없을 때 데이터를 그대로 전달하는 메서드.
    - HTTP 통신에서 프록시 서버는 통신 데이터를 통해 수신자를 판단, HTTPS 통신은 데이터를 암호화하여 수신자 확신 불가.
    - 프록시 서버를 통해 HTTPS 통신을 할 때는 CONNET 메서드가 반드시 필요하지만 수신자를 제한하지 않으면 공격자가 악용 가능.
    - TRACE는 XST (cross site tracing) 을 통한 정보 유출의 위험이 있어 현재 거의 모든 브라우저가 지원 X.
    
    ### 3.1.6 상태 코드
    
    - 1xx 현재 처리중.
    -- 100 Continue : 서버처리 완료 X. 현재 요청 진행 중.
    - 2xx 정상 처리.
    -- 200 OK : 정상 완료.
    -- 201 Created : 정상 생성 완료.
    - 3xx 리다이렉트.
    -- 301 Moved Permanently : 지정한 리소스가 다른 장소로 이동된 상태.
    -- 302 Found : 지정한 리소스가 일시적으로 이동한 상태. 서버 임시 점검 등에 사용.
    - 4xx 문제 상황.
    -- 400 Bad Request : 오류 상태.
    -- 404 Not Found : 지정한 리소스 존재 X.
    - 5xx 서버에 문제 발생.
    -- 500 Internal Server Error : 서버 내부에 에러 발생.
    -- 503 Service Unavailable : 서버 다운 혹은 점검 등 처리 불가 상태.
    
    ### 3.1.7 HTTP 헤더
    
    - 대표적인 Request 헤더 : Host, User-Agent, Referer
    - 대표적인 Reseponse 헤더 : Server, Location
    - 대표적인 엔티티 헤더 (둘다 사용 헤더 entity herder) : Content-Length, Content-Type
    
    ### 3.1.8 쿠키를 사용한 상태 관리
    
    - HTTP는 원래 문서 전송을 위해 개발된 프로토콜.
    - 브라우저와 서버간의 상태 관리 필요 X.
    - HTTP로 데이터 전송 시도 증가로 인해 쿠키라는 보관 방식 발생.
    
    ## 3.2 HTTP 실습하기
    
    ### 3.2.1 GET과 POST로 데이터 전송하기
    
    ### 3.2.2 상태 코드 확인 및 변경하기
    
    - 개발자가 상태 코드 지정하지 않아도 200,404 등 몇가지는 프레임워크인 Express가 판단해 자동 설정.
    
    ### 3.2.3 임의로 HTTP 헤더 추가하기
    
    ## 3.3 안전한 통신을 위한 HTTPS
    
    - HTTP 프로토콜은 HTML 문서를 전송하기 위해 고안.
    - 보안 고려 X.
    - 이를 보완하기 위해 HTTPS 등장.
    
    ### 3.3.1 HTTP의 약점
    
    - 크게 3가지 약점.
        - 1. 통신 데이터 도청 가능. -> HTTP는 암호화 시스템 X.
        - 2. 통신 상대의 진위 여부 확인 불가. -> 통신 대상이 실제 서버인지 진위 확인 불가. 서버인척 공격 가능.
        - 3. 통신 과정에서 데이터 수정 여부 확인 불가. -> 통신 과정에서 공격자가 수정해도 확인 불가.
    
    ### 3.3.2 HTTP 약점을 해결하는 TLS
    
    - 세가지 약점 때문에 HTTPS (HTTP over TLS) 등장.
    - HTTPS = TLS라는 통신 프로토콜을 사용해 암호화하는 구조.
    - HTTP 통신 전 TLS 핸드쉐이크(handshake) 라는 일련의 암호 통신 과정 진행.
    - TLS
        - 1. 통신 데이터 암호화 -> 데이터를 암호화하는 기능과 데이터의 변조를 막는 기능 제공.
        - 2. 통신 상대 검증 -> 전자 인증서로 통신 상대 확인. 신뢰 가능한 기관인 CA(certificate authority)에서 발행한 인증서와 서버에서 전송된 인증서 대조.
        - 3. 통신 데이터 변경 체크 -> 데이터 변조를 체크하는 기능 제공.
    
    ### 3.3.3 HTTPS 도입 권장
    
    - HTTPS가 아닌 HTTP 웹에 접근하려 하면 경고문이 표시됨.
    
    ### 3.3.4 안전한 콘텍스트만 이용 가능한 API
    
    - 안전한 콘텍스트(Secure Context)
        - https:// 또는 wss:// 의 암호화 통신을 사용.
        - [http://localhost](http://localhost/), [http://127.0.0.1](http://127.0.0.1/), file:// 의 URL로 시작하는 로컬 호스트 통신.
    - Secure Context의 스펙은 W3C의 'Secure Context'에 정의되어 있으며, Secure Context로 볼수있는 패턴이 도형으로 정리되어 있음.
    
    ### 3.3.5 Mixed Content의 위험성
    
    - Mixed Content : HTTPS를 사용한 웹 앱에서 HTTP 통신을 사용하는 리소스가 혼재되어 있는 상태.
    - HTTPS를 도입했더라도 사용하는 js와 이미지 등의 하부 리소스가 HTTP 통신을 사용하면 안전 X.
        - HTTP로 받은 js 파일을 HTTPS의 웹 앱에서 호출시 위험.
        - 따라서 Mixed Content가 위험.
    - Mixed Content의 두가지 패턴.
        - Passive mixed content : 이미지와 영상, 음성파일과 같은 리소스가 Mixed Content를 유발하는 패턴.
        - 리소스가 변경되면 잘못된 정보 표시.
        - 비교적 작은 영향력.
        - Active mixed content : 자바스크립트와 CSS 등 브라우저에서 실행되는 코드에 대한 Mixed Content 패턴.
        - 보안 공격과 같은 문제 위험.
        - 통신 중 변조하거나 악성 리소스 투입 가능.
        - 민감한 정보가 유출되거나 금전적인 손해가 발생 가능.
        - 비교적 큰 피해 위험.
        - 대부분의 브라우저는 이미 Active mixed content의 하부 리소스 접근 차단.
    
    ### 3.3.6 HSTS를 사용해 HTTPS 통신 강제하기
    
    - HTTPS를 사용한 웹 앱에서 HTTP 접속을 허용하는 경우 존재.
    - HSTS(HTTP strict transport security) 구조를 적용하면 가능.
    - HSTS를 유효화하려면 응답 헤더에 Strict-Transport-Security 헤더를 추가.

## 다음 시간 :   5/8 수  저녁 7시

Chapter 4. Origin에 의한 애플리케이션 간 접근 제한 까지 읽어보고 오기.