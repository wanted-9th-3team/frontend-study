# 05/22 기술 스터디

작성 일시: 2024년 5월 22일 오후 6:49
최종 편집 일시: 2024년 5월 22일 오후 10:53
작성자: 김진영
참석자: 김진영, 재욱 김, 명훈
상태: Backlog

## 이번시간

- **프런트엔드 개발을 위한 보안 입문**
- Chapter 5. XSS 까지 읽어보고 오기.

5장에서는 동일 출처 정책을 우회하는 수동적 공격과 대표 기법인 XSS(cross site scripting)를 설명한다.

- XSS는 공격자가 만든 함정에 의해 브라우저에서 공격자의 코드를 실행시키는 공격이다.
- XSS는 동일 출처 정책으로는 막을 수 없다.
- XSS는 라이브러, 프레임워크, 브라우저의 기능을 사용해서 막을 수 있다.
- CSP는 XSS 등 인젝션 공격을 막기 위한 브라우저의 기능이다.
- CSP는 강력하지만 웹 애플리케이션이 동작할 때 문제가 생길 수 있으므로 보고서를 모니터링하면서 적용해야 한다.

- 능동적 공격과 수동적 공격
    
    ### 수동적 공격
    
    능동적 공격과는 달리 공격자가 직접 웹 애플리케이션을 공격하지는 않는다. 
    공격을 트리거하는 것은 페이지 접근, 링크 클릭 등 사용자에 의한 조작이다.
    
- XSS
    
    XSS는 웹 애플리케이션의 취약점을 이용해 악성 스크립트를 실행하는 공격이다.
    
    교차 출처 페이지에서 실행되는 자바스크립트 공격은 동일 출처 정책에 의해 차단되지만, XSS는 공격 대상 페이지에서 자바스크립트를 실행하므로 동일한 출처 정책으로는 막을 수 없다.
    
    취약성 대책 정보 데이터베이스인 ‘보안 취약점 정보 포털’, 'HackerOne’  등의 사이트에서 리포트 건수가 가장 많은 것이 XSS다.
    
    취약성 진단 도구를 사용한다고 해도 모든 공격 방법을 고려해 완전한 대책을 세우기는 어렵다.
    
    ### XSS 구조
    
    XSS 공격은 피싱 사이트를 만들어두는 형태일 수도 있고, 평범한 사이트의 취약점을 이용해 스크립트를 주입하는 것일 수도 있다.
    
    ### 세 가지 XSS
    
    - 반사형 XSS:
        
        공격자가 준비한 함정에서 발생하는 요청에 잘못된 스크립트를 포함하는 HTML을 서버에서 생성해 발생하는 XSS다.
        
        요청에 포함된 코드를 응답 HTML에 그대로 출력하기 때문에 반사형 XSS라고 한다.
        
        잘못된 스크립트가 포함된 요청을 보낸 사용자만 반사형 XSS의 영향을 받는다.
        
        **즉시 실행되며, 주로 URL을 통해 전달됨.**
        
    - 저장형 XSS:
        
        공격자가 폼 등으로부터 제출한 악성 스크립트를 포함하는 데이터가 서버에 저장되고 저장된 데이터 내 악성 스크립트가 웹 애플리케이션 페이지에 반영되어 발생하는 XSS다.
        
        데이터베이스에 등록된 데이터가 반영되는 페이지를 보는 모든 사용자에게 영향을 미친다.
        
        **서버에 저장되어 여러 사용자에게 영향을 미침.**
        
    - DOM 기반 XSS
        
        →
        
    
    ### DOM 기반 XSS
    
    다른 XSS는 서버 코드의 결함이지만 DOM 기반 XSS는 프런트엔드의 코드 결함 때문에 발생한다.
    
    서버를 통하지 않으므로 공격울 감지하기 어려운 특징도 있다.
    
    `innerHTML` 을 사용해 DOM을 조작한 것이 DOM 기반 XSS의 원인이 될 수 있다.
    
    DOM 기반 XSS를 발생시키는 원인이 되는 location, hash 문자열과 같은 것을 ‘소스’라고 하며 소스의 문자열에서 자바스크립트를 생성하고 실행하는 것(`innerHTML` 등)을 '싱크’라고 한다.
    
    ### XSS 대책
    
    (XSS 대책의 구조를 배우기 위해 이스케이프 처리 등 기본적인 대책을 배우면 좋지만, 실제로 애플리케이션을 개발할 때는 xss를 자동으로 예방해주는 라이브러리나 프레임워크를 사용하는 것이 좋다.)
    
    이스케이프처리, 따옴표문제, 스키마 제한, innerHTML 안쓰기, httpOnly, 프레임워크 이용, Sanitizer API
    

- 재욱
    
    Chapter 5. XSS
    
    5.1 능동적 공격과 수동적 공격
    
    - 동일 출처 정책을 우회하는 능동적 공겨과 수동적 공격.
    - 웹 애플리케이션 공격 -> 능동적 공격(active attack) 과 수동적 공격(passive attack)
    
    5.1.1 능동적 공격
    
    - 능동적 공격은 공격자가 웹 애플리케이션에 직접 공격 코드를 보내는 공격 유형.
        - 데이터베이스를 조작하기 위해 SQL을 서버로 전송하는 SQL 인젝션.
        - OS를 조작하기 위해 명령을 서버로 전송하는 OS 명령 인젝션.
    
    5.1.2 수동적 공격
    
    - 공격자가 준비한 피싱 사이트를 이용해 웹 애플리케이션에 방문한 사용자가 공격 코드를 실행하도록 하는 공격 방법.
    - 능동적 공격과는 달리 공격자가 직접 웹 애플리케이션을 공격 X.
    - 공격을 트리거하는 것은 페이지 접근，링크 클릭 등 사용자에 의한 조작.
    - 공격자가 제공한 피싱 사이트에 사용자가 접속하면 페이지에 설치된 도구를 통해 대상 웹 애플리케이션에 대한 공격 코드가 실행.
        - 기밀 정보 유출이나 권한을 악용한 웹 애플리케이션에 대한 공격.
        - 공격을 받는 사용자가 스스로 공격 코드를 실행하게 되므로 공격자가 직접 접근할 수 없는 인트라넷의 웹 애플리케이션이나 로그인 후의 페이지도 공격
    - 웹 애플리케이션의 대표적인 수동적 공격 네가지.
        - XSS (cross site scripting)
        - CSRF (cross site req uest forgery)
        - 클릭재킹 (clickjacking)
        - 오픈 리다이렉트 (open redirect)
    - 능동적 공격은 서버가 직접 공격받으므로 서버에서 대책.
    - 수동적 공격은 프런트엔드에서만 가능한 부분 존재.
    
    5.2 XSS
    
    - 웹 애플리케이션의 취약점을 이용해 악성 스크립트를 실행하는 공격.
    - 교차 출처 페이지에서 실행되는 자바스크립트 공격은 동일 출처 정책에 의해 차단,
    - xss는 공격 대상 페이지에서 자바스크립트를 실행하므로 동일한 출처 정책으로 방어 불가.
    
    5.2.1 XSS 구조
    
    - XSS는 공격자가 페이지의 HTML에 악성 스크립트를 삽입해 사용자가 악성 스크립트를 실행하게 만드는 공격 방법.
    - XSS는 사용자가 입력한 문자열을 그대로 HTML에 삽입할 때 발생하는 취약점.
    
    5.2.2 XSS 위협
    
    - 모든 XSS 취약점을 고려 불가.
    - 숙련된 개발자나 취약성 진단 도구가 문제 없다고 판단해도 xss 공격 성공 가능.
    - 유튜브나 트위터와 같이 유명한 웹 서비스도 과거에 xss 취약성 발견.
    - XSS의 취약점을 완전히 없애기는 어렵지만 모든 XSS가 중대한 문제를 일으키는 것 X.
    - 웹 애플리케이션의 성격이나 발생하는 XSS에 따라 큰 피해를 일으키지 않을 때 존재.
    - But, XSS는 피해 규모에 상관없이 다음과 같이 다양한 문제 야기.
        - 보안 정보의 유출
            - 웹 애플리케이션의 보안 정보를 탈취해 공격자 서버로 전송.
        - 웹 애플리케이션 변조
            - 가짜 정보를 표시하기 위해 웹 애플리케이션 변조.
        - 의도치 않은 조작
            - 의도되지 않은 웹 애플리케이션 및 사용자의 조작 실행.
        - 사용자로 위장
            - 공격자가 사용자의 세션 정보를 취득해 사용자로 위장
        - 피싱
            - 가짜 폼이 표시되어 사용자가 개인 정보와 계정 정보（사용자 ID, 비밀번호 등）를 입력하고 이를 통해 중요한 개인 정보 유출.
    
    5.2.3 세 가지 XSS
    
    - XSS 공격은 다양한 방법이 있지만 CWE 에서는 크게 세 가지로 분류.
        - 반사형 XSS (reflected XSS)
            - 공격자가 준비한 함정에서 발생하는 요청에 잘못된 스크립트를 포함하는 HTML을 서버에서 생성해 발생하는 XSS.
            - 요청에 포함된 코드를 응답 HTML에 그대로 출력하기 때문에 반사형 XSS.
            - 반사형 XSS는 요청 내용에 잘못된 스크립트가 포함된 경우에만 발생.
            - 지속성이 없으므로 비지속형 XSS (non-persistentXSS) 라고도 칭함.
            - 잘못된 스크립트가 포함된 요청을 보낸 사용자만 반사형 XSS의 영향.
            - 요청의 내용을 그대로 응답의 HTML에 반영하는 작업이 반사형 XSS의 원인.
        - 저장형 XSS (stored XSS)
            - 공격자가 폼 등으로부터 제출한 악성 스크립트를 포함하는 데이터가 서버에 저장되고 저장된 데이터 내 악성 스크립트가 웹 애플리케이션 페이지에 반영되어 발생하는 XSS.
            - 악성 스크립트를 포함하는 데이터가 서버에 저장되므로 저장형 XSS.
            - 저장형 XSS는 데이터베이스에 등록된 데이터가 반영되는 페이지를 보는 모든 사용자에게 영향.
            - 반사형 xss와 달리 공격은 한 번으로 끝나는 것이 아니라 정상적인 요청을 하는 사용자에게도 피해.
            - 서버에 저장된 악성 스크립트를 포함하는 데이터를 삭제하거나 애플리케이션의 코드를 수정하지 않으면 저장형 XSS의 피해 지속.
            - 지속적으로 XSS 공격이 이뤄지므로 지속형 XSS (persistent XSS) 라고도 칭함.
            - ex) 사용자가 전송한 텍스트나 이미지를 다른 사용자가 볼 수 있는 SNS 서비스.
            - 불특정 다수의 사용자에 대해 XSS 공격이 계속 발생하므로 저장형 XSS는 가장 위험한 공격.
        - DOM 기반 XSS (DOM-based XSS)
    - 반사형 XSS와 저장형 XSS는 웹 애플리케이션의 서버 코드의 결함으로 인해 발생.
    - DOM 기반 XSS는 프런트엔드의 코드 결함으로 발생.
    - 세 가지 모두 사용자의 브라우저에서 공격 코드가 실행되는 공통점.
    
    5.2.4 DOM 기반 XSS
    
    - 자바스크립트로 DOM (document object model)을 조작할 때 발생하는 XSS.
    - 다른 XSS는 서버 코드의 결함이지만 DOM 기반 XSS는 프런트엔드의 코드 결함 때문에 발생.
    - 서버를 통하지 않으므로 공격을 감지하기 어려운 특징.
    - 프런트엔드의 자바스크립트는 개발자 도구로 코드를 볼 수 있다는 것도 공격자가 노릴 수 있는 취약점 중 하나.
    
    5.2.4.1 DOM
    
    - DOM이란 HTML을 조작하기 위한 인터페이스.
    - 브라우저는 HTML 구문을 해석해 DOM 트리라고 하는 구조를 생성.
    - 생성된 DOM 트리는 자바스크립트로 내용을 변경.
    - DOM 트리의 내용이 바뀌면 DOM 트리의 원본이 되는 HTML도 다시 생성되므로 자바스크립트로 화면에 표시되는 내용 변경 가능.
    
    5.2.4.2 DOM 기반 XSS 발생 사례
    
    - DOM 기반 XSS는 브라우저의 기능을 사용할 때 발생.
    - DOM 기반 XSS의 원인이 되는 브라우저의 기능은 소스와 싱크로 분류 가능.
    - '소스' = DOM 기반 XSS를 발생시키는 원인이 되는 location.hash 문자열과 같은 것
    - '싱크' = 소스의 문자열에서 자바스크립트를 생성하고 실행하는 것
        - 소스로 동작하는 기능의 대표적인 예
            - location.hash
            - location.search
            - location.href
            - document.referrer
            - postMessage
            - Web Storage
            - IndexedDB
        - 싱크로 동작하는 기능의 대표적인 예
            - innerHTML
            - eval
            - location.href
            - document.write
            - jQueryO
    - 소스와 싱크로 동작하는 기능은 보통은 위험하지는 않지만 주의해서 사용.
    - 전달하는 데이터를 적절히 처리하면 XSS는 발생 X.
    
    5.2.5 XSS 대책
    
    - 실제로 애플리케이션을 개발할 때는 xss를 자동으로 예방해주는 라이브러리나 프레임워크를 사용 지향.
    - 라이브러리나 프레임워크에서 어떤 처리를 하는지，처리를 하지 않을 때 취해야 할 방법이 무엇인지를 이해하기 위해 기본적인 방법 학습.
    
    5.2.5.1 문자열 이스케이프 처리
    
    - XSS는 악성 스크립트를 포함하는 문자열을 HTML에 삽입하고 브라우저가 삽입한 문자열을 HTML로 처리하기 때문에 발생.
    - XSS를 방지하려면 문자열에 이스케이프를 처리하여 HTML로 해석하지 않도록 처리.
    - 이스케이프 처리는 프로그램에 특별한 의미를 갖는 문자나 기호를 특별하지 않은 의미로 변환 처리하는 작업.
    - 이스케이프 처리를 자동으로 해주는 라이브러리나 프레임워크를 사용하면 개발자는 스스로 이스케이프 처리를 구현하지 않아도 되므로 이 방법 추천.
    
    5.2.5.2 속성값의 문자열을 쌍따옴표로 감싸기
    
    - HTML의 속성값에 문자열을 넣으면 이스케이프 처리로는 예방 불가.
    - HTML의 속성값으로 문자열을 출력할 때는 속성값을 쌍따옴표로 묶고 이스케이프 처리.
    
    5.2.5.3 링크의 URL 스키마를 http/https로 제한하기
    
    - <a> 요소의 href 속성을 이용한 XSS 공격은 앞에서 설명한 이스케이프 처리와 쌍따옴표를 묶는 방법으로도 예방 불가.
    - <a> 요소의 href 속성은 http 또는 https 스키마분만 아니라 자바스크립트 스키마도 지정 가능.
    - 코드에서 쿼리 스트링의 값이 http:// 또는 [https://로](https://xn--2o2b/) 시작하는지 확인하고 둘 중의 하나와 일치할 때만 값을 href 속성에 할당.
    - <a> 요소에 href 속성을 동적으로 할당할 때 대입값에 문제가 없는지 체크.
    
    5.2.5.4 DOM 조작을 위한 메서드와 프로퍼티 사용하기
    
    - DOM 기반 XSS는 문자열을 HTML로 해석하는 innerHTML 등의 기능을 사용할 때 발생.
    - 브라우저에서 자바스크립트로 DOM을 조작할 때 HTML로 해석하는 API의 사용을 피하면 DOM 기반 XSS 방지 가능.
    - 사용자가 입력한 데이터를 DOM 조작 함수와 프로퍼티를 사용해 텍스트 노드로 사용하도록 수정.
    
    5.2.5.5 쿠키에 HttpOnly 속성을 추가하기
    
    - 웹 애플리케이션에 XSS 취약성이 있으면 쿠키의 값이 유출되어 공격자가 사용자로 위장 가능.
    - 서버에서 쿠키를 발행할 때 HttpOnly 속성을 부여하면 XSS에 의한 쿠키의 유출 위험 감소 가능.
    - HttpOnly 속성을 부여하면 자바스크립트로 쿠키값 사용 불가.
    - 자바스크립트로 쿠키값을 반드시 다뤄야 하는 상황이 아니라면 HttpOnly 속성 부여 지향.
    - XSS 취약점을 통해 악성 스크립트가 HTML에 포함되더라도 쿠키에 접근할 수 없으면 피해 감소.
    
    5.2.5.6 프레임워크의 기능을 사용하는 방법
    
    - React, Vue.js, Angular와 같은 프레임워크는 XSS가 발생하지 않도록 프레임워크 내부에서 자동으로 이스케이프를 처리.
    - 라이브러리나 프레임워크를 사용하면 XSS를 편리하게 예방할 수 있지만 완전 방지 X.
    
    5.2.5.7 DOMPurify 라이브러리를 사용하는 방법
    
    - <script>와 onmouseover 등의 삽입에 의한 자바스크립트 실행은 방지하면서 <br〉，<p>와 같이 무해한 HTML을 허용하고 싶을 때는 단순히 모든 문자열의 이스케이프 처리로는 불가능.
    - HTML에 삽입하는 문자열부터 자바스크립트를 실행시키는 일부 HTML 문자열만 제거하는 방법 필요.
    - 가장 신뢰할 수 있는 XSS 대책 중 하나.
    - DOMPurify는 브라우저에서 실행되는 프런트엔드 자바스크립트에서도 사용할 수 있으며 Node.js 서버의 자바스크립트에서도 사용 가능.
    - DOMPurify를 사용하면 DOM 기반 XSS를 방지 가능.
    - innerHTML이나 React의 dangerouslySetlnnerHTML과 같이 DOM 기반 XSS를 유발하는 기능을 사용해야 할 때도 DOMPurify와 같은 라이브러리를 사용하면 XSS의 발생 방지 가능.
    
    5.2.5.8 Sanitizer APK 사용하는 방법
    
    - Sanitizer API는 브라우저의 새로운 API.
    - DOMPurify와 같이 XSS의 원인이 되는 위험한 문자열을 제거하는 API.
    - Sanitizer 클래스를 사용.
    - new Sanitizer()로 Sanitizer 클래스의 인스턴스를 생성하고 setHTML 함수를 사용해 문자열을 삽입할 때 Sanitizer의 인스턴스를 사용해 처리.
    - Sanitizer API를 사용하면 unsafeString에서 XSS의 원인이 되는 문자열을 삭제 가능.
    
    5.3 XSS 방지 실습 ( 실습하기 생략 )
    
    5.3.1 적절한 DOM API를 사용하는 방법
    
    5.3.2 URL 스키마를 http/https로 한정하기
    
    5.3.3 XSS 문제를 줄이는 DOMPurify 라이브러리 사용하기
    
    5.4 Content Security Policy를 사용한 XSS 대처하기
    
    - CSP (content security policy) : XSS와 같이 악성 코드를 포함하는 인젝션 공격을 감지해 피해를 막는 브라우저의 기능.
    
    5.4.1 CSP 개요
    
    - 서버에서 허용되지 않은 자바스크립트의 실행과 리소스 불러오기 등을 차단.
    - 대부분의 브라우저에서 CSP를 지원.
    - Content-Security-Policy 헤더를 응답에 포함해 활성화 가능.
    - 응답 헤더뿐 아니라 다음과 같이 HTML에 <meta> 요소로 CSP 설정을 포함 가능.
    - 서버를 필요로 하지 않는 정적 사이트에서도 CSP를 사용 가능.
    - 단, HTTP 헤더에서 CSP 설정이 우선되거나 일부 설정을 사용할 수 없다는 점에서 주의 필요.
    - Content-Security-Policy 헤더에 지정된 script-src *.trusted.com와 같은 값을 policy directive 또는 간단하게 directive 라고 칭함.
    - directive는 콘텐츠 유형별로 리소스를 불러오는 방법의 제한을 지정.
    - <meta> 요소를 사용해 CSP를 설정하면 directive는 content 값으로 설정.
    - directive에 지정되지 않은 호스트명의 서버에서는 자바스크립트 파일 불러오지 않음.
    - 정책을 위반하는 파일을 불러오려고 하면 브라우저는 이를 차단하고 에러를 발생.
    - 자바스크립트 파일을 불러오는 페이지와 같은 호스트명의 서버에서 불러오기, 즉 자신의 도메인에서 호스팅 하는 자바스크립트의 불러오기도 제한.
    - 같은 호스트에서 자바스크립트를 불러오려면 다음과 같이 self 키워드를 사용.
    - 여러 directive를 지정하려면 세미콜론(;) 사용.
    
    5.4.1.1 대표적인 directive
    
    - script-src
        - 자바스크립트 등 스크립트 실행 허용.
    - style-src
        - CSS 등 스타일 적용 허용.
    - img-src
        - 이미지 불러오기 허용.
    - media-src
        - 사운드, 영상 불러오기 허용.
    - connect-src
        - XHR 과 fetch 함수 등 네트워크 접근 허용.
    - default-src
        - 지정되지 않은 directive 전체 허용.
    - frame-ancestors
        - iframe 등 현재 페이지에 삽입 허용.
    - upgrade-insecure-requests
        - [http://로](http://xn--2o2b/) 시작하는 URL 리소스를 [https://로](https://xn--2o2b/) 시작하는 URL로 변환하여 요청.
    - sandbox
        - 콘텐츠를 샌드박스화하여 외부로부터 접근 등을 제어.
    - <meta> 요소를 사용해 CSP를 활성화할 때는 다음의 directive를 지정 불가.
        - frame-ancestors
        - report-uri
        - sandbox
    
    5.4.1.2 소스 키워드
    
    - 소스에 지정할 수 있는 특별한 의미가 있는 키워드.
        - self
            - CSP로 보호하는 페이지와 동일 출처만 허용.
        - none
            - 모든 출처 허용하지 않음.
        - unsafe-inline
            - script-src와 style-src의 directive에서 인라인 스크립트 및 인라인 스타일을 사용하도록 허용.
        - unsafe-eval
            - script-src의 directive에서 eval 함수 사용 허용.
        - unsafe-hashes
            - script-src의 directive에서 DOM에 설정된 onclick와 onfocus 등의 이벤트 실행을 허용하지만 <script> 요소를 사용해 인라인 스크립트 또는 자바스크립트:스키마를 사용하는 자바스크립트 실행은 허용 X.
    
    5.4.2 Strict CSP
    
    - CSP를 적용한 페이지는 HTML 내 자바스크립트를 작성하는 인라인 스크립트가 금지.
    - 인라인 스크립트를 사용하려면 권장하지 않는 unsafe-inline 키워드를 사용해야 함.
    - 따라서 안전하게 인라인 스크립트와 인라인 스타일을 실행하도록 허용하려면 nonce-source와 hash-source라는 CSP 헤더를 사용해야 함.
    - 호스트명을 지정하는 CSP 설정을 사용한 웹 애플리케이션은 호스트에 제공되는 콘텐츠와 자바스크립트를 사용하면 CSP를 우회하여 XSS 공격이 가능.
    - 호스트명을 지정하는 대신 nonce-source와 hash-source를 사용한 Strict CSP를 추천.
    
    5.4.2.1 nonce-source
    
    - <script> 요소에 지정된 랜덤 토큰이 CSP 헤더에 지정된 토큰과 일치하지 않으면 에러를 발생시키는 기능.
    - 지정하는 토큰은 고정된 값은 아니며 요청마다 토큰을 변경해 공격자가 추측하지 못하도록 처리 지향.
    
    5.4.2.2 hash-source
    
    - none-source와 같이 토큰을 지정해 인라인 스크립트의 실행을 허용하는 기능의 일종.
    - CSP 헤더에 자바스크립트와 CSS 코드의 해시값(해시 함수로 계산된 값)을 지정.
    - HTML, CSS, 자바스크립트로만 구성되고, 서버가 없는 정적 사이트는 요청마다 nonce 값을 생성할 수는 없지만 hash-source를 사용하면 안전하게 CSP를 설정 가능.
    - 따라서 HTML을 동적으로 변경할 수 없는 경우 요청마다 토큰을 바꿀 수 없으므로 nonce-source를 사용하지 않고 hash-source 사용 지향.
    
    5.4.2.3 strict-dynamic
    
    - nonce-source나 hash-source를 사용하면 인라인 스크립트를 안전하게 실행 가능.
    - 그러나 이를 통해 허용된 자바스크립트 코드에서도 동적인 <script> 요소의 생성은 금지.
    - <script> 요소를 동적으로 생성하고 싶을 때는 strict-dynamic 키워드를 사용.
    - strict-dynamic를 지정하면 앞에서 설명한 <script> 요소의 동적 생성을 허용.
    - 단, DOM 기반 XSS의 싱크인 innerHTML과 document.write는 기능이 제한.
    
    5.4.2.4 object-src/base-uri
    
    - object-src는 플래시와 같은 플러그인을 제한하는 directive.
    - object-src 를 'none' 으로 설정하면 플래시와 같은 플러그인을 악용한 공격을 방지 가능.
    - base-uri는 <base> 요소를 제한하는 directive.
    - <base> 요소는 링크와 리소스 URL의 기준이 되는 URL을 설정하는 HTML 요소.
    - 공격자가 <base> 요소를 삽입하면 상대 경로에 지정된 URL을 공격자가 준비한 피싱 사이트의 URL로 변경 가능.
    - base-uri 를 'none' 으로 지정해 <base> 요소의 사용을 방지
    
    5.4.3 문자열을 안전한 타입으로 사용하는 Trusted Types
    
    - Strict CSP는 강력한 XSS 대책이지만 여전히 개발자의 구현 방식에 따라 DOM 기반 XSS가 발생할 가능성 존재.
    - DOM 기반 XSS는 문자열을 그대로 HTML에 삽입하게 되어 문제.
    - 검사되지 않은 문자열을 HTML에 삽입하는 것을 금지하는 Trusted Types의 브라우저 기능 존재.
    - Trusted Types는 기본값이 비활성화 상태이므로 웹 애플리케이션과의 호환성 문제 야기 X.
    - Trusted Types는 policy라고 하는 함수가 검사한 안전한 타입만 HTML에 삽입하도록 제한.
    - Trusted Types는 문자열을 TrustedHTML, TrustedScript, Trusted ScriptURL의 세 가지 유형으로 변환.
        - HTML String -> TrustedHTML
        - Script String -> TrustedScript
        - Script URL -> TrustedScriptURL
    - Trusted Types를 활성화하려면 require-trusted-types-for 'script' 를 CSP 헤더에 지정.
        - Content-Security-Policy: require-trusted-types-for 'script';
    - Trusted Types은 지금까지 설명한 CSP와 똑같이 <meta> 요소를 사용해 설정하는 것도 가능.
    - 문자열을 검사하고 Trusted Types의 안전한 타입으로 변환하는 방법 세 가지.
    
    5.4.3.1 policy 함수에 의한 검사와 변환
    
    - policy 함수는 window.trustedTypes.createPolicy 함수를 사용.
    - policy 함수에서 DOMPurify 등의 라이브러리도 사용 가능.
    - 여러 개의 policy를 적용하면 CSP 헤더의 trusted-types의 directive를 사용해 policy 이름을 지정 가능.
    - 지정한 policy 이름 이외의 policy 함수가 있으면 에러가 발생.
    - policy명을 명시적으로 지정하면 개발자는 policy 함수의 코드만 리뷰하거나 확인하면 된다는 장점 존재.
    
    5.4.3.2 디폴트 policy에 의한 검사와 변환
    
    - policy 함수의 policy명에 default를 지정하면 Trusted Types의 디폴트 policy를 사용 가능.
    - Trusted Types의 타입이 아닌 일반 문자열을 싱크에 대입하면 디폴트 policy가 문자열을 자동으로 검사.
    - policy 함수를 만들거나 기존 코드를 수정하지 않아도 디폴트 policy를 추가하면 Trusted Types를 적용할 수 있으므로 편리
    - 단, 싱크에 대입하고 있는 모든 부분에 적용되므로 Trusted Types의 영향으로 웹 애플리케이션에 문제가 발생하더라도 쉽게 눈치채기 어려운 부분이 있으므로 주의.
    - policy를 작성하고 하나씩 동작을 확인하면서 적용하는 것이 안전.
    
    5.4.3.3 라이브러리에 의한 검사와 변환
    
    - Trusted Types를 지원하는 라이브러리를 사용하면 자체적으로 policy 함수를 만들 필요 X.
    - DOMPurify와 Trusted Types를 지원하고 다음과 같이 RETURN_TRUSTED_TYPE 옵션을 인수로 지정한 sanitize 함수는 TrustedHTML 타입의 결과를 반환.
    - Trusted Types는 DOM 기반 XSS를 차단하는 강력한 기능.
    - Trusted Types을 구현함에 있어 빠진 부분이 있으면 웹 애플리케이션이 동작하지 않을 가능성 존재.
    - Trusted Types을 프로덕션에서 사용하기 전에 다음에서 설명할 Report-Only 모드를 사용해 테스트 지향 추천.
    
    5.4.4 Report-Only 모드를사용한 policy 테스트
    
    - CSP는 XSS를 막는 강력한 수단이지만 잘못 구현하면 CSP 적용 전에 작동에 문제가 발생 가능.
    - CSP를 적용할 때는 웹 애플리케이션을 손상시킬 위험이 없는지 테스트로 확인 필수.
    - 테스트를 위해 준비된 것이 Report-Only 모드.
    - Report-Only 모드는 CSP를 적용할 때 발생하는 영향을 요약한 보고서를 JSON 형식으로 전송하는 기능.
    - 웹 애플리케이션에서는 실제 CSP가 적용되어 있지 않으면 동작에 영향이 없지만 적용된 경우에는 영향도를 테스트.
    - Report-Only 모드를 적용하려면 Content-Policy-Report-Only 헤더를 사용.
    - policy를 하나 이상 지정하는 것도 가능.
    - 실제 CSP 적용 후에도 보고서를 전송 가능.
    - 실제로 활용할 때는 서버로 전송된 JSON 데이터를 데이터베이스에 저장하고 Redash 등을 사용해 개발자가 보고서의 내용을 쉽게 검색할 수 있도록 하는 것 추천.
    - User-Agent 등의 헤더 정보도 저장해두면 사용자가 사용한 브라우저의 정보 등을 확인할 수 있어 에러를 확인할 때 도움.
    - 단, Report-Only 모드는 다음과 같이 <meta> 요소로 설정 불가.
    - 실제로 CSP를 적용하기 전에 Report-Only 모드로 몇 주에서 몇 달 동안 운영해보고 CSP 위반이 없는지 확인하는 것 추천.
    - 실제로 CSP를 적용하면서 보고서를 제출 가능.
    - CSP는 강력한 XSS의 대책이지만 잘못 설정하면 웹 애플리케이션이 동작 X.
    - 따라서 Report-Only 모드에서 충분히 확인한 후 실제 CSP를 적용.
    - 적용한 후에도 계속 보고서를 전송해 반복해서 확인 지향.
    
    5.5 CSP 설정 실습하기 ( 실습하기 생략 )
    
    5.5.1 nonce-source 를 사용한 CSP 설정하기
    
    5.5.2 strict-dynamic을 사용해 동적으로 <script> 요소 생성하기
    
    5.5.3 Trusted Types 설정 방법
    
    마무리
    
    - XSS는 공격자가 만든 함정에 의해 브라우저에서 공격자의 코드를 실행시키는 공격.
    - XSS는 동일 출처 정책으로는 방어 불가.
    - XSS는 라이브러리，프레임워크，브라우저의 기능을 사용해서 방어 가능.
    - CSP는 XSS 등 인젝션 공격을 막기 위한 브라우저의 기능.
    - CSP는 강력하지만 웹 애플리케이션이 동작할 때 문제가 생길 수 있으므로 보고서를 모니터링하면서 적용 필수.

## 다음 시간 :   5/29 수  저녁 7시

- Chapter 6. 기타 수동적인 공격 : CSRF, 클릭재킹, 오픈 리다이렉트 까지 읽어보고 오기.