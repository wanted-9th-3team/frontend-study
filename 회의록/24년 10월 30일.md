# 10/30 기술 스터디

회의일: 2024년 10월 30일
작성자: 김재욱
참가자: 김재욱, 명훈

## 이번시간

- **자바스크립트 + 리액트 디자인 패턴** (- 자바스크립트와 리액트의 최신 패턴과 렌더링, 성능 패턴까지)
- Chapter 10 모듈형 자바스크립트 디자인 패턴,
- Chapter 11 네임 스페이스 패턴 까지.
- p274 까지.

- 재욱
    - Chapter 10 모듈형 자바스크립트 디자인 패턴
        - AMD
            - AMD(Asynchronous Module Definition) 모듈 형식 : 모듈과 의존성 모두를 비동기적으로 로드 할 수 있도록 설계된 모듈 정의 방식.
            - 비동기적이면서도 높은 유연성 ⇒ 모듈 간 긴밀한 결합을 줄여줌 ⇒ 유지보수 증가.
            - 두가지 중요 개념.
                - define 메서드 : 모듈 정의 구현.
                - require 메서드 : 의존성 로딩 처리.
            - AMD가 모듈형 자바스크립트 작성에 적합한 이유
                - 유연한 모듈 정의 방식에 대한 명확한 제안을 제공.
                - 기존에 많이 사용되고 있는 전역 네임스페이스나 <script> 태그 방식에 비해 훨씬 더 구조화 가능. → 독립적인 모듈과 의존성을 명확하게 선언 가능.
                - 모듈 정의가독립적으로 이루어지기 때문에 전역 네임스페이스의 오염 방지 가능.
                - 크로스 도메인, 로컬 환경, 디버깅 등에서 문제가 없으며, 서버 사이드 툴을 사용할 필요 X.
                - 여러 모듈을 하나의 파일로 가져오기 위한 ‘전송(transport)’ 방식 제공.
                - 스크립트의 지연 로딩(lazy-load) 지원.
            - 결론
                - 전역 객체의 사용에 대한 걱정 감소.
                - 변수에 모듈 할당 가능.
                - 브라우저 환경의 모듈 작동을 위해 서버 사이드에서의 따로 변환 필요 X.
                - 의존성 관리 측면에서 매우 효율적.
                - 단, 초기 설정 코드(boilerplate/wrappercode) 작성이 다소 귀찮.
        - Common JS
            - 서버 사이드에서 모듈을 선언하는 간단한 API를 지정하는 모듈 제안.
            - AMD와는 달리 I/O, 파일 시스템, 프로미스 등 더욱 광범위한 부분을 다룸.
            - 두가지 핵심 요소.
                - exports 변수 : 다른 모듈에 내보내고자 하는 객체.
                - require 함수 : 다른 모듈에서 내보낸 객체를 가져올 때 사용하는 함수.
            - Node.js 환경에서는 CommonJS가 기본 형식.
                - require() 함수를 호출하면 항상 CommonJS 모듈 로더가 사용되고, import() 함수를 호출하면 항상 ECMAScript 모듈 로더가 사용됨.
            - AMD VS CommonJS
                - AMD
                    - 브라우저 우선 접근 방식.
                    - 비동기 동작과 간소화된 하위 호환성을 선택.
                    - 파일 I/O에 대한 개념 X.
                    - 객체, 함수, 생성자, 문자열, JSON 등 다양한 형태의 모듈을 지원.
                    - 브라우저에서 자체적으로 실행된다는 면에서 대단히 유연한 포맷.
                - CommonJS
                    - 서버 우선 접근 방식.
                    - 동기적 작동, 전역 변수와의 독립성, 미래의 서버 환경 고려.
                    - 언래핑된(unwrapped) 모듈을 지원하기 때문에 ES2O15+ 표준에 조금 더 가깝 → AMD에서 필수적인 define() 함수를 사용 X.
                    - 오직 객체만을 모듈로써 지원.
                - UMD
                    - Universal Module Definition 형식
                    - AMD와 Commorjs의 약점을 해결하는 방안.
                    - 브라우저와 서버 환경에서 모두 작동할 수 있는 모듈.
    - Chapter 11 네임 스페이스 패턴
        - 단일 전역 변수 패턴
            - 하나의 전역 변수를 주요 참조 객체로 사용하는 방식.
            - 같은 이름의 전역 변수를 이미 사용하고 있을 가능성 존재. ⇒ 충돌 발생.
        - 접두사 네임스페이스 패턴
            - Prefix Namespace 패턴
            - 단일 전역 변수 문제에 대한 해결책 중 하나.
            - 모든 메서드, 변수, 객체를 고유한 접두사 뒤에 붙여서 정의.
            - 단점
                - 애플리케이션이 커짐에 따라 많은 전역 객체 생성.
                - 같은 접두사를 전역 네임스페이스에서 사용하지 않고 있었을 것이라는 가정 필요.
        - 객체 리터럴 표기법 패턴
            - 객체 리터럴 표기법 (Object Literal Notation)
                - 일종의 객체.
                - 키와 값으로 이뤄진 집합.
                - 각각의 키와 값은 콜론(:)으로 구분.
            - 장점
                - 전역 네임스페이스를 오염시키지 않으면서도 코드와 매개변수를 논리적으로 구성.
                - 쉽게 읽을 수 있고，깊은 중첩까지 지원하는 구조를 구현할 때 매우 유용.
                - 일반적인 전역 변수들과 달리 동일한 이름의 변수가 있는지 검사하도록 설계되는 경우가 많아 충돌 가능성 크게 감소.
                
                ```jsx
                1. var myApplication = myApplication || {};
                2. if( !MyApplication ){ MyApplication = {} }; 
                3. window.myApplication || ( window.myApplication = {} ); 
                4. var myApplication = $.fn.myApplication = function() {}; 
                5. var myApplication = myApplication === undefined ? {} : myApplication;
                ```
                
                - 캡슐화 및 로직 분리 ⇒ 코드 확장.
        - 중첩 네임스페이스 패턴
            - Nested Namespace 패턴
                - 객체 리터럴 패턴을 발전시킨 형태
                - 다른 패턴에 비해 충돌 위험이 낮은 편.
                - 같은 이름의 네임스페이스가 존재한다고 해도, 하위에 중첩된 네임스페이스까지 정확하게 일치할 가능성이 낮기 때문.
                - 참조해야할 일이 더 많아질 수 있지만, 단일 객체 네임스페이스 패턴과 중첩 네임스페이스 패턴의 성능에 큰차이 X.
        - 즉시 실행 함수 표현식 패턴
            - 즉시 실행 함수 표현식 (Immediately Invoked Function Expressions) (IIFE )
                - 정의 직후 바로 실행되는, 이름이 없는 함수.
                - 자기 실행(혹은 자기 호출) 익명 함수.
                - 정의된 내부의 변수와 함수 모두 외부에서 접근 불가.
                - 호출하는 것만으로도 쉽게 코드의 은닉성을 구현 가능.
                - 로직을 캡슐화하여 전역 네임스페이스로부터 보호하는 데 널리 사용되는 방법.
        - 네임 스페아스 주입 패턴
            - Namespace injection 패턴
                - 즉시 실행 함수 패턴의 또 다른 변형.
                - 함수 내에서 this를 네임스페이스의 프록시로 활용하여 특정 네임스페이스에 메서드와 속성을 ‘주입’.
                - 여러 객체나 네임스페이스에 기능적인 동작을 쉽게 적용 가능.
                - 단, 같은 목적을 달성하는 더 쉽고 효율적인 방법 (예: 심층 객체 확장 또는 병합) 존재 가능.
        - 고급네임스페이스 패턴
            - 중첩 네임스페이스 자동화 패턴
                - 추가하고자 하는 계층이 늘어날수록 최상위 네임스페이스에 더 많은 하위 객체들이 정의되어야 한다는 점을 보완 가능.
                - 전역 변수 하위에 중첩된 네임스페이스를 자동으로 정의하는 방법.
                
                ```jsx
                 // 최상위 네임스페이스에 객체 리터럴을 할당합니다. 
                const myApp = {};
                
                // 문자열 형식의 네임스페이스를 파싱하고
                // 자동으로 중첩 네임스페이스를 생성해주는 간편한 함수입니다. 
                function extend( ns, ns_string ) {
                	  const parts = ns_string.split
                	  let parent = ns;
                	  let pl;
                	  pl = parts.length;
                	 
                	  for ( let i = 0; i < pl; i++ ) { 
                	  // 프로퍼티가 존재하지 않을 경우에만 생성합니다. 
                				if ( typeof parent[parts[i]] === "undefined" ) { 
                						parent[parts[i]J = {};
                				}
                				parent = parent[parts[i]];
                		}
                	  return parent;
                }
                ```
                
            - 의존성 선언(Dependency Decision) 패턴
                - 중첩 네임스페이스 패턴을 약간 변형한 형태.
                
                ```jsx
                 myApp.utilities.math.fibonacci(25);
                 myApp.utilities.math.sin(56);
                ->
                 const maths = utils.math;
                 maths.fibonacci(25);
                 maths.sin(56);
                ```
                
                - 매번 접근하는 것보다 더 편리하고 가독성 증가 및 성능 이점.
                - 모듈 단위로 작업할 때 가장 효과적.
            - 심층 객체 확장(Deep Object Extension) 패턴
                - 자동 네임스페이스 생성에 대한 또 다른 해결책.
                - 객체 리터럴 표기법으로 선언된 네임스페이스를 다른 객체 (또는 네임스페이스)와 쉽게 확장(또는 병합) 가능.
                - 자바스크립트 프레임워크를 사용하면 쉽게 객체를 확장 가능. (예: jQuery의 $.extend)

참고 자료 : [https://www.patterns.dev/](https://www.patterns.dev/)

## 다음 시간 :  11/13 수  저녁 7시

- **자바스크립트 + 리액트 디자인 패턴** (- 자바스크립트와 리액트의 최신 패턴과 렌더링, 성능 패턴까지)
- Chapter 12 리액트 디자인 패턴 까지.
- p330 까지.