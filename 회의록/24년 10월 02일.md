# 10/02 기술 스터디

작성 일시: 2024년 10월 2일 오후 5:45
최종 편집 일시: 2024년 10월 2일 오후 7:31
작성자: 재욱 김
참석자: 재욱 김, 명훈, 김진영
상태: Backlog

## 이번시간

- **자바스크립트 + 리액트 디자인 패턴** (- 자바스크립트와 리액트의 최신 패턴과 렌더링, 성능 패턴까지)
- Chapter 8 자바스크립트 MV 패턴 까지.
- p202 까지.

- 재욱
    - Chapter 8 자바스크립트 MV 패턴
        - MVC 패턴 (모델-뷰-컨트롤러) (Model-View-Controller)
            - 애플리케이션의 구조를 개선하기 위해 관심사의 분리를 활용하는 아키텍처 디자인 패턴.
            - 비즈니스 데이터(모델)과 UI(뷰)를 분리하고, 세 번째 구성 요소(컨트롤러)가 로직과 사용자 입력을 관리하는 구조.
            - 현재 자바스크립트는 MVC (또는 다른 MV* 변형 패턴)를 지원하는 여러 프레임워크를 갖추고 있음.
                - Backbone.js, Ember.js, AngulaiJS 뿐만 아니라.
                - 리액트(React), 앵귤러(Angular), Vue.js 생태계에서 MV* 패턴의 다양한 변형 버전이 구현.
            - 모델
                - 애플리케이션의 데이터를 관리하는 역할.
                - ui나 프레젠테이션 계층은 담당하지 않고, 애플리케이션에 필요한 고유 데이터 형식.
                - 비즈니스 데이터와 주로 관련.
            - 뷰
                - 모델에 대한 시각적인 표현.
                - 현재 상태의 특정 부분.
                - Smalltalk의 뷰가 비트맵을 생성하고 관리하는 역할이라면, 자바스크립트의 뷰는 여러 DOM 요소의 집합을 생성하고 정리하는 역할.
                - 모델을 관찰하고, 모델에 변화가 생기면 알림받는 역할.
            - 컨트롤러
                - 컨트롤러는 모델과 뷰 사이의 중재자 역할.
                - 사용자가 뷰를 조작할 때 모델을 업데이트하는 역할.
                - 모델과 뷰 간의 로직과 연동을 관리.
            - MVC를 사용하는 이유
                - 전반적인 유지보수의 단순화.
                - 모델과 뷰의 분리 →  비즈니스 로직에 대한 단위(unit) 테스트의 작성이 훨씬 간편.
                - 모델 및 컨트롤러 코드 중복 제거.
                - 역할의 분리 정도에 따라, 모듈화를 통해 여러 개발자가 동시에 작업 가능.
        - MVP 패턴 (모델-뷰-프리젠터) (Model-View-Presenter)
            - 프레젠테이션 로직의 개선에 초점을 맞춘 MVC 디자인 패턴의 파생.
            - MVC와 마찬가지로 여러 구성 요소 간의 관심사 분리를 목표로 하지만, 몇 가지 근본적인 차이점 존재.
            - 프리젠터(Presenter)
                - MVP에서 P는 프리젠터(Presenter)를 의미.
                - 뷰에 대한 UI 비즈니스 로직을 담당하는 구성 요소.
                - MVC와 달리, 뷰에서의 이벤트 호출은 프리젠터로 위임.
                - 뷰와 분리되어 있으며, 인터페이스를 통해 뷰와 통신.
                - 단위 테스트에서 뷰를 모킹(mocking) 할 수 있는 등의 많은 장점 제공.
            - 장단점
                - 장점 : 애플리케이션의 테스트 용이성 증가 및 뷰와 모델 간의 분리 명확.
                - 단점 : 데이터 바인딩 지원 X. → 작업을 별도로 처리해야 하는 비용 발생.
            - MVC 와 MVP
                - MVP는 일반적으로 프레젠테이션 로직을 최대한 재사용해야 하는 엔터프라이즈 수준의 애플리케이션에서 사용.
                - 뷰가 매우 복잡하고 사용자와의 상호작용이 많은 애플리케이션에서는 MVC가 적합 X.
                - MVP에서는 이 모든 복잡한 로직을 프리젠터 안에 캡슐화할 수 있어 유지보수에 유리.
                - 프리젠터에서 모킹을 사용하여 다른 구성 요소와 독립적으로 단위 테스트 가능. → MVC의 단점 커버 가능.
        - MVVP 패턴 (모델-뷰-뷰모델) (Model-View-ViewModel)
            - MVC와 MVP를 기반으로 하는 아키텍처 패턴.
            - 애플리케이션의 UI 개발 부분과 비즈니스 로직, 동작 부분을 명확하게 분리.
            - UI 작업과 개발 작업을 거의 동시에 진행 가능.
                - UI 개발자는 문서 마크업(HTML) 내에서 뷰모델에 대한 바인딩을 작성.
                - 애플리케이션 로직을 담당하는 개발자들은 모델과 뷰모델을 관리.
            - 모델
                - 다른 MV* 패턴들과 마찬가지.
                - 다만 기존 모델을 정의하거나 업데이트 하는 데 사용되는 데이터에 대한 유효성 검사는 모델에서 수행하는 것이 허용.
            - 뷰모델
                - 데이터 변환기의 역할을 하는 특수한 컨트롤러.
                - 모델의 정보를 뷰가 사용할 수 있는 형태로 변환, 뷰에서 발생한 명령(사용자의 조작이나 이벤트)을 모델로 전달.
            - 뷰는 자체 UI 이벤트를 처리하고, 필요에 따라 뷰모델에 연결(upping).
            - 모델과 뷰모델의 속성은 양방향 데이터 바인딩을 통해 동기화되고 업데이트.
            - 장점
                - UI와 이를 구동하게 해주는 요소를 동시에 개발 가능.
                - 뷰를 추상화함으로써 뷰의 뒤에 작성되는 비즈니스 로직(또는 연결 코드)의 양 감소.
                - 이벤트 중심 코드에 비해 단위 테스트 간단.
                - 뷰모델은 (뷰보다는 모델에 가까우므로) UI 자동화나 싱호작용에 대한 고려 없이도 테스트 가능.
            - 단점
                - 단순한 UI의 경우, 과도한 구현(overkill) 가능.
                - 데이터 바인딩은 선언적이고 사용하기 편리할 수 있지만, 단순히 중단점(breakpoints)을 설정하는 명령형 코드에 비해 디버깅이 더 어려움.
                - 복잡한 애플리케이션에서는, 데이터 바인딩이 상당한 관리 부담 야기 가능.
                - 대규모 애플리케이션에서는 필요한 일반화를 제공하기 위해 뷰모델을 미리 설계하는 것이 부담.
        - MVC vs MVP vs MVVM
            - MVP와 MVVM은 모두 MVC에서 파생된 패턴.
            - MVC
                - 뷰가 아키텍처의 최상단에 위치, 그 옆에 컨트롤러.
                - 모델은 컨트롤러 아래 존재.
                - 뷰가 모델에 직접 접근 가능.
                - → 애플리케이션의 복잡도에 따라 보안 및 성능 문제 야기 가능.
                - 이러한 문제를 피하기 위한 MVVM 패턴.
            - MVP
                - 컨트롤러의 역할이 프리젠터로 대체.
                - 프리젠터는 뷰와 동일한 계층에 존재.
                - 뷰와 모델 양쪽에서 발생하는 이벤트를 수신하고 이들 간의 동작을 조정.
                - MVVM과는 달리, 뷰와 뷰모델을 바인딩하는 메커니즘 X.
                - → 각 뷰는 프리젠터가 뷰와 상호작용할 수 있도록 인터페이스를 구현.
            - MVVM
                - 상태와 로직 정보를 포함할 수 있는 뷰와 관련된 모델 일부를 생성 가능.
                - → 뷰에 전체 모델 노출 방지 가능.
                - MVP의 프리젠터와 달리, 뷰모델은 뷰를 참조할 필요 X.
                - 뷰는 뷰모델의 속성을 바인딩하여 모델에 포함된 데이터를 뷰에 표현 가능.
                - 뷰가 추상화되어 뷰에 필요한 로직의 양 감소.
                - 다만 복잡한 대규모 프로젝트에선 성능에 영향 가능.

참고 자료 : [https://www.patterns.dev/](https://www.patterns.dev/)

## 다음 시간 :  10/16 수  저녁 7시

- 일단 둘이서 진행.
- 변동사항은 단톡방에서 논의하는 방향으로.

- **자바스크립트 + 리액트 디자인 패턴** (- 자바스크립트와 리액트의 최신 패턴과 렌더링, 성능 패턴까지)
- Chapter 9 비동기 프로그래밍 패턴 까지.
- p226 까지.